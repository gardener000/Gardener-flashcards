// data/aai_chap3_2.js
export default {
  name: "汇编Chap3:寻址方式（下）",
  data: [
    {front:"基址相对加变址寻址 (Base Relative-Plus-Index) 📦",back:`<dl><dt>公式 (最全数据寻址)</dt><dd>EA = <mark>Base</mark> + <mark>Index</mark> + <mark>Displacement</mark></dd><dt>特点</dt><dd>将 <mark>基址寄存器</mark> (Base)、<mark>变址寄存器</mark> (Index) 和 <mark>位移量</mark> (Disp) 三者相加，计算最终有效地址。</dd><dt>应用场景</dt><dd>访问 <mark>二维数组</mark> 或 <mark>结构体数组</mark> 中的成员 (如 C 语言中的 $\\text{foos[i].d}$)。</dd></dl>`},
    {front:"比例变址寻址 (Scaled-Index Addressing) 📏",back:`<dl><dt>公式 (完全体)</dt><dd>EA = Base + (<mark>Scale</mark> $\\times$ Index) + Displacement</dd><dt>Scale 因子</dt><dd>一个固定乘数，只能是 <mark>1, 2, 4, 8</mark>。</dd><dt>用途</dt><dd>访问 <mark>非字节数组</mark> (e.g., int/double) 元素。<br>它将地址计算中的 $\\text{index} \\times \\text{size}$ 乘法 <mark>一步到位</mark> 集成到硬件中，避免额外 $\\text{MUL/SHL}$ 指令，提高效率。</dd><dt>兼容性</dt><dd>始于 $\\text{80386}$ 处理器。</dd></dl>`},
    {front:"程序内存寻址 (JMP/CALL) 的核心 🧭",back:`<dl><dt>用途</dt><dd>用于 <mark>控制流指令</mark> ($\text{JMP}, \\text{CALL}$)，操作数是 <mark>目标地址</mark>。</dd><dt>相对偏移 (Relative)</dt><dd>目标地址 = 当前 $\\text{IP/EIP}$ + <mark>相对位移量</mark> (指令中编码)。优点：生成 <mark>位置无关代码 (PIC)</mark>。</dd><dt>绝对偏移 (Absolute/Direct)</dt><dd>目标地址 = <mark>硬编码的完整值</mark> ($\text{JMP seg:off}$)。用于 <mark>远跳转 (Far Jump)</mark>，同时加载新的 $\\text{CS}$ 和 $\\text{IP}$。</dd><dt>间接跳转 (Indirect)</dt><dd>目标地址存放在 <mark>寄存器</mark> 或 <mark>内存单元</mark> 中 (e.g., $\\text{JMP EAX}, \\text{JMP [TABLE+BX]}$)。常用于实现 <mark>跳转表</mark> ($\text{switch-case}$)。</dd></dl>`},
    {front:"<mark>RIP 相对寻址</mark> (64位模式) 🛡️",back:`<dl><dt>公式</dt><dd>EA = <mark>RIP</mark> + Displacement</dd><dt>RIP</dt><dd>64位 <mark>指令指针</mark> 寄存器，总是指向下一条指令的地址。</dd><dt>用途</dt><dd>访问全局/静态变量，指令中只存相对偏移，使得代码 <mark>位置无关 (PIC)</mark>，对共享库至关重要。</dd><dt>Canonical Form (规范地址)</dt><dd>有效的 64 位地址，其高位部分 ($\text{48-63位}$) 必须全部与 <mark>第 47 位</mark> 相同 (实现硬件地址检查)。</dd></dl>`},
    {front:"栈操作 (<mark>PUSH/POP</mark>) 原理与机制 ⬇️⬆️",back:`<dl><dt>特性</dt><dd><mark>LIFO</mark> (后进先出)。x86 栈 <mark>向下生长</mark> (地址减小)。</dd><dt>栈管理者</dt><dd><mark>SS</mark> (栈段寄存器) 和 <mark>SP/ESP/RSP</mark> (栈顶指针，指向栈顶最后一个占用元素)。</dd><dt>PUSH AX 过程</dt><dd>1. $\\text{SP} = \\text{SP} - 2$ (<mark>先减</mark>)。<br>2. $\\text{AX}$ 内容存入 $\\text{SS}:[\\text{SP}]$ 处 (<mark>后存</mark>)。</dd><dt>POP BX 过程</dt><dd>1. $\\text{BX}$ 存入 $\\text{SS}:[\\text{SP}]$ 处 (<mark>先取</mark>)。<br>2. $\\text{SP} = \\text{SP} + 2$ (<mark>后加</mark>)。</dd></dl>`},
    {front:"栈操作系列指令 <mark>PUSHA/POPA</mark> & <mark>PUSHF/POPF</mark> 💾",back:`<dl><dt>PUSHA/PUSHAD</dt><dd>批量保存 <mark>所有通用寄存器</mark> 状态 (保存现场)。<br>64 位模式下 <mark>不可用</mark>。</dd><dt>POPA 顺序</dt><dd>弹出顺序与 $\\text{PUSHA}$ <mark>相反</mark>，符合 LIFO 原则。SP 的值在 $\\text{POPA}$ 中被弹出但 <mark>丢弃</mark> (SP 最终值由指令自然增加决定)。</dd><dt>PUSHF/POPF</dt><dd>用于保存和恢复 <mark>标志寄存器 (FLAGS/EFLAGS)</mark> 的状态 (常用于 <mark>中断处理</mark> 和需要精确控制标志位的场合)。</dd></dl>`},
    {front:"<mark>Intel</mark> vs <mark>AT\&T</mark> 语法：核心差异总结 🔄",back:`<dl><dt>操作数方向</dt><dd>Intel: $\\text{Destination, Source}$ (<mark>右 $\\to$ 左赋值</mark>)。<br>AT&T: $\\text{Source, Destination}$ (<mark>左 $\\to$ 右阅读</mark>)。</dd><dt>前缀</dt><dd>AT&T 寄存器加 <mark>%</mark> ($\text{%eax}$)，立即数加 <mark>$</mark> ($\text{\$100}$)。Intel 无前缀。</dd><dt>内存寻址格式</dt><dd>Intel: $\\text{[base + index} \\times \\text{scale + disp]}$ (直观)。<br>AT&T: $\\text{disp(base, index, scale)}$ (函数调用式)。</dd><dt>大小指定</dt><dd>Intel: <mark>前缀指示符</mark> ($\text{BYTE PTR}$)。<br>AT&T: 指令后加 <mark>后缀</mark> ($\text{b, w, l, q}$)。</dd></dl>`},
    {front:"<mark>Intel</mark> vs <mark>AT\&T</mark> 语法：优缺点 ⚖️",back:`<dl><dt>Intel 优点</dt><dd><mark>简洁</mark>、<mark>直观</mark> ($\text{Dest, Src}$ 似赋值)；<mark>广泛支持</mark> (工业标准)。</dd><dt>Intel 缺点</dt><dd>存在 <mark>歧义</mark> (类型和大小隐式)，有时需手动添加 $\\text{PTR}$ 指示符。</dd><dt>AT&T 优点</dt><dd><mark>语法明确</mark>，通过 $\\text{%, \$, 后缀}$ <mark>显式指明</mark> 操作数类型和大小，减少歧义。</dd><dt>AT&T 缺点</dt><dd>冗长复杂，操作数方向和内存格式 <mark>反直觉</mark> (与 C 语言习惯不同)。</dd></dl>`},
    {front:"数据寻址 <mark>万能公式</mark> 及其 <mark>简化</mark> 总结 ✅",back:`<dl><dt>核心</dt><dd>EA = <mark>Base</mark> + (<mark>Index</mark> $\\times$ <mark>Scale</mark>) + <mark>Displacement</mark></dd><dt>寄存器间接</dt><dd>仅用 $\\text{Base}$ (e.g., $\\text{[rbx]}$)。</dd><dt>寄存器相对</dt><dd>用 $\\text{Base} + \\text{Disp}$ (e.g., $\\text{[rbx+16]}$)；常用于 <mark>结构体成员</mark> 访问。</dd><dt>基址加变址</dt><dd>用 $\\text{Base} + \\text{Index}$ (e.g., $\\text{[rbx+r15]}$)；常用于 <mark>一维数组</mark> 访问。</dd><dt>基址相对加变址</dt><dd>用 $\\text{Base} + \\text{Index} + \\text{Disp}$ (e.g., $\\text{[rbx+r15+32]}$)；常用于 <mark>二维数组/结构体数组</mark> 访问。</dd><dt>比例变址</dt><dd>用 $\\text{Base} + \\text{Index} \\times \\text{Scale}$ (完全体)；常用于 <mark>非字节数组</mark> 访问。</dd></dl>`}
  ]
};