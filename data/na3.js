// data/interpolation-full.js
export default {
  name: "计算理论：插值与多项式逼近",
  data: [
    {
      front: "什么是 <mark>插值</mark> (Interpolation)？ 🤔",
      back: `<dl>
        <dt>核心动机</dt>
        <dd>根据一系列已知的数据点 (x₀, y₀), (x₁, y₁)... 构造一个函数去<mark>近似</mark>未知函数 f(x)，用于预测或填充数据。</dd>
        <dt>插值 vs. 逼近</dt>
        <dd><b>逼近 (Approximation):</b> 找到一个简单的 g(x) 在<mark>总体上</mark>靠近 f(x)，不要求经过任何特定点。<br>
        <b>插值 (Interpolation):</b> 一种更严格的逼近，构造的 g(x) <mark>必须精确地穿过</mark>所有已知的数据点，即 g(xᵢ) = yᵢ。</dd>
        <dt>为何用多项式？</dt>
        <dd>结构简单、计算方便（只有加法和乘法）、性质良好（无限次可微）、且理论保证（魏尔斯特拉斯逼近定理）任何连续函数都可用多项式以任意精度逼近。</dd>
      </dl>`
    },
    {
      front: "内插 (Interpolation) vs. 外插 (Extrapolation) 🎯",
      back: `<dl>
        <dt>定义</dt>
        <dd><b>内插:</b> 在已知数据点的<mark>区间内部</mark>进行估计。例如，已知 30° 和 60° 的值，估计 50° 的值。<br>
        <b>外插:</b> 在已知数据点的<mark>区间外部</mark>进行预测。例如，已知 30° 和 45° 的值，预测 50° 的值。</dd>
        <dt>可靠性</dt>
        <dd>内插是基于数据的“包围”进行估计，通常<mark>更可靠</mark>，误差更小。<br>
        外插是在“预测”函数在未知区域的行为，<mark>风险很大</mark>，误差通常会急剧增大。</dd>
        <dt>结论</dt>
        <dd><b>In general, interpolation is better than extrapolation.</b> 除非有充分的理由，否则应避免外插。</dd>
      </dl>`
    },
    {
      front: "拉格朗日插值法 (Lagrange) 如何工作？ 🔧",
      back: `<dl>
        <dt>核心思想</dt>
        <dd>将插值多项式 Pn(x) 看作是各个数据点 yᵢ 的<mark>加权和</mark>：<br>
        Pₙ(x) = Σ yᵢ * Lᵢ(x)</dd>
        <dt>基函数 (Basis Functions)</dt>
        <dd>Lᵢ(x) 是拉格朗日基函数，它像一个“<mark>开关</mark>”。利用克罗内克 Delta 性质: Lᵢ(xⱼ) = 1 (若 i=j), 0 (若 i≠j)。</dd>
        <dt>基函数的构造</dt>
        <dd>利用“开关”性质构造：<br>分子：为了在所有 xⱼ (j≠i) 处为0，必须包含 (x-x₀)...(x-xₙ) 但跳过 (x-xᵢ) 项。<br>分母：为了在 xᵢ 处为1，用分子在 xᵢ 处的值作归一化。<br>
        公式: <mark>Lᵢ(x) = Π (x - xⱼ) / (xᵢ - xⱼ)</mark>  (其中 j≠i)</dd>
      </dl>`
    },
    {
      front: "插值多项式是 <mark>唯一</mark> 的吗？ ☝️",
      back: `<dl>
        <dt>唯一性定理</dt>
        <dd>对于 n+1 个不同的数据点，满足插值条件且<mark>次数不超过 n</mark> 的多项式是<mark>唯一</mark>的。</dd>
        <dt>证明思路 (反证法)</dt>
        <dd>1. <b>假设不唯一</b>：存在两个不同的多项式 Pₙ(x) 和 Qₙ(x) 都满足条件。<br>
        2. <b>构造差函数</b>：D(x) = Pₙ(x) - Qₙ(x)。它的次数也 ≤ n。<br>
        3. <b>分析根</b>：在所有插值点 xᵢ 上，D(xᵢ) = yᵢ - yᵢ = 0。所以 D(x) 有 <mark>n+1</mark> 个不同的根。<br>
        4. <b>导出矛盾</b>：根据代数基本定理，一个非零的 n 次多项式最多有 n 个根。要使 D(x) 有 n+1 个根，它必须是<mark>零多项式</mark>，即 D(x) ≡ 0。<br>
        5. <b>得出结论</b>：因此 Pₙ(x) = Qₙ(x)，与假设矛盾。所以多项式是唯一的。</dd>
      </dl>`
    },
    {
      front: "插值 <mark>误差</mark> 有多大？ 📈",
      back: `<dl>
        <dt>误差定义</dt>
        <dd>误差 Rₙ(x) = f(x) - Pₙ(x)，即真实函数与插值多项式之间的差距。</dd>
        <dt>误差公式</dt>
        <dd>Rₙ(x) = <mark>[f⁽ⁿ⁺¹⁾(ξₓ) / (n+1)!] * Π(x - xᵢ)</mark><br>其中 ξₓ 是一个介于最小和最大插值点之间的未知数。</dd>
        <dt>误差取决于三要素</dt>
        <dd>1. <b>函数本身</b>：f⁽ⁿ⁺¹⁾(ξₓ) - 函数的高阶导数。函数越“平滑”（高阶导数小），误差越小。<br>
        2. <b>插值点数量</b>：(n+1)! - 分母项。插值点越多，n 越大，该项增长飞快，有助于减小误差。<br>
        3. <b>插值点分布</b>：Π(x - xᵢ) - 插值点 xᵢ 的分布情况和待求点 x 的相对位置。</dd>
      </dl>`
    },
    {
      front: "应用：如何用误差公式控制精度？ 📐",
      back: `<dl>
        <dt>问题背景</dt>
        <dd>为函数 f(x) (例如 eˣ) 在区间 [a, b] 制作一个函数值表，要求用户使用<mark>线性插值</mark> (n=1) 时，其绝对误差 |R₁(x)| 不超过给定的 ε (例如 10⁻⁶)。问：函数表的步长 h 最大可以是多少？</dd>
        <dt>解决步骤</dt>
        <dd>1. <b>写出误差公式</b>：|R₁(x)| = |[f''(ξ) / 2!] * (x-xᵢ)(x-xᵢ₊₁)| ≤ ε<br>
        2. <b>误差放缩</b>：找到误差公式中每一部分在区间内的<mark>最大值</mark>。<br>
        &nbsp;&nbsp;&nbsp;• 找到 |f''(ξ)| 的上界 M₂ = max|f''(x)|。<br>
        &nbsp;&nbsp;&nbsp;• |(x-xᵢ)(x-xᵢ₊₁)| 在中点处取最大值 h²/4，其中 h = xᵢ₊₁ - xᵢ。<br>
        3. <b>建立不等式</b>：[M₂ / 2] * [h²/4] ≤ ε。<br>
        4. <b>求解步长 h</b>：从不等式中解出 h，即 h ≤ sqrt(8ε / M₂)。这便得到了满足精度要求的<mark>最大允许步长</mark>。</dd>
      </dl>`
    },
    {
        front: "内维尔法 (Neville's Method) 的递推思想  टेबल",
        back: `<dl>
            <dt>动机</dt>
            <dd>克服拉格朗日法<mark>无法迭代</mark>的缺点。内维尔法提供了一种<mark>递推</mark>方案，可以逐次增加数据点来构造更高阶的插值多项式。</dd>
            <dt>核心递推公式</dt>
            <dd>一个经过点 xᵢ 到 xⱼ 的 k 阶多项式 Pᵢ,..,ⱼ(x)，可以由两个 k-1 阶的多项式<mark>线性组合</mark>而成。<br>
            例如 P₀,₁,₂(x) 是由 P₀,₁(x) 和 P₁,₂(x) 构造。</dd>
            <dt>内维尔表</dt>
            <dd>通过一个表格自左向右计算：<br>
            第0列：P₀, P₁, P₂ ... (0次多项式)<br>
            第1列：P₀,₁, P₁,₂ ... (1次多项式)<br>
            第2列：P₀,₁,₂ ... (2次多项式)<br>
            表格中的每一项都由其左侧相邻的两项计算得出。</dd>
            <dt>优点</dt>
            <dd>适合在<mark>单点求值</mark>并观察对角线上的值是否<mark>收敛</mark>，从而判断精度是否足够，但它不直接给出多项式的最终表达式。</dd>
          </dl>`
    },
    {
      front: "牛顿插值法 (Newton) 与 <mark>差商</mark> ⚙️",
      back: `<dl>
        <dt>动机</dt>
        <dd>兼顾<mark>迭代能力</mark>和<mark>表达式输出</mark>。克服拉格朗日法的“推倒重来”和内维尔法的“只算不说”的缺点。</dd>
        <dt>牛顿形式</dt>
        <dd>Nₙ(x) = f[x₀] + f[x₀,x₁](x-x₀) + f[x₀,x₁,x₂](x-x₀)(x-x₁) + ...<br>这种<mark>嵌套结构</mark>易于扩展。增加新点只需在末尾追加一项，前面的系数<mark>保持不变</mark>。</dd>
        <dt>差商 (Divided Differences)</dt>
        <dd>牛顿多项式的系数 aₖ 就是 k 阶<mark>差商</mark> f[x₀, ..., xₖ]。通过<mark>差商表</mark>系统地计算所有系数，其结构与内维尔表类似。</dd>
        <dt>优点</dt><dd>集<mark>继承性</mark>（易于增加新点）和<mark>表达式优美</mark>于一身，是实际应用中最常用的方法。</dd>
      </dl>`
    },
    {
      front: "等距节点：<mark>差分</mark> 简化计算 📏",
      back: `<dl>
        <dt>适用场景</dt>
        <dd>当插值节点在 x 轴上<mark>等距离</mark>分布时，即 xᵢ = x₀ + i*h，h 为步长。</dd>
        <dt>差分 (Finite Differences)</dt>
        <dd>复杂的差商可以被简单的<mark>差分</mark>运算替代。<br>
        <b>前向差分 (Δ):</b> Δfᵢ = fᵢ₊₁ - fᵢ<br>
        <b>高阶:</b> Δᵏfᵢ = Δ(Δᵏ⁻¹fᵢ)</dd>
        <dt>牛顿前向差分公式</dt>
        <dd>通过变量替换 t = (x-x₀)/h，牛顿公式可简化为：<br>
        N(x₀+th) = Σ (t choose k) * Δᵏf₀ <br>
        其中 (t choose k) 是广义二项式系数。此公式非常适合待求点靠近数据表<mark>起始位置</mark>的情况。（类似地，还有后向差分公式，适用于靠近末尾的情况）</dd>
      </dl>`
    },
    {
      front: "高阶插值的<mark>龙格现象</mark>与<mark>样条插值</mark> 🎢",
      back: `<dl>
        <dt>阶数越高越好吗？</dt>
        <dd><mark>不是！</mark>当插值点很多时，使用一个极高阶的多项式穿过所有点，会在数据点之间（尤其是在区间两端）产生<mark>剧烈的振荡</mark>，这被称为<b>龙格现象 (Runge's Phenomenon)</b>。</dd>
        <dt>解决方案：分段插值</dt>
        <dd>用一系列<mark>低阶</mark>多项式分段连接数据点，而不是用一个高阶多项式。这能更好地适应函数的局部特性。</dd>
        <dt>样条插值 (Spline)</dt>
        <dd>最常用的解决方案是<b>三次样条插值 (Cubic Spline)</b>。它不仅要求分段的三次多项式在连接点处值相等，还要求<mark>一阶和二阶导数也连续</mark>，从而保证整条曲线在连接处是<mark>高度光滑的</mark>，这是计算机图形学和CAD设计的基石。</dd>
      </dl>`
    },
    {
      front: "如何插值非函数曲线？<mark>参数插值</mark> 🌀",
      back: `<dl>
        <dt>问题</dt>
        <dd>标准插值 y=P(x) 无法处理一条曲线在同一个 x 值上有多个 y 值的情况（例如圆形或闭合曲线）。</dd>
        <dt>解决方案：引入参数</dt>
        <dd>将 x 和 y 都看作是第三个变量——参数 <mark>t</mark> 的函数：<br>
        x = x(t)<br>
        y = y(t)<br>
        问题转化为两个独立的标准插值问题：(tᵢ, xᵢ) 和 (tᵢ, yᵢ)。</dd>
        <dt>如何选择参数 t ?</dt>
        <dd>1. <b>简单方法</b>：按点的序号赋值，t = 0, 1, 2, ...<br>
        2. <b>弦长参数化 (Chord Length)</b>：t 值等于从起点开始沿数据点折线路径的<mark>累积长度</mark>。这种方法能更好地反映点之间的实际“距离”，通常效果更好。</dd>
        <dt>实施</dt>
        <dd>分别构造插值多项式 Pₓ(t) 和 Pᵧ(t)。通过让 t 在其范围内平滑变化，就可以得到一系列 (x, y) 坐标点，从而绘制出平滑的插值曲线。</dd>
      </dl>`
    }
  ]
};