// data/os_virtual_mem.js
export default {
  name: "操作系统：虚拟内存（上）",
  data: [
    {front:"虚拟内存的核心思想是什么？ 🤔", back:`<dl><dt>核心概念</dt><dd>将用户的 <mark>逻辑内存</dt><dd>与 <mark>物理内存</mark> 分离。</dd><dt>工作方式</dt><dd>程序以为自己独占巨大、连续的内存空间（逻辑地址），而操作系统负责将其映射到有限、非连续的物理内存上。</dd><dt>形象比喻</dt><dd>物理内存是图书馆的 <mark>有限座位</mark>，逻辑内存是给每个读者的 <mark>巨大虚拟书架</mark>。管理员（OS）负责在你需要时把书（数据页）从书库（硬盘）拿到座位上。</dd></dl>`},
    {front:"虚拟内存带来了哪些好处？ 🚀", back:`<dl><dt>无需完整加载</dt><dd>程序只需加载当前需要的部分即可运行，启动更快，内存占用更少。</dd><dt>超大地址空间</dt><dd>逻辑地址空间可以远大于物理内存，能运行比物理内存还大的程序。</dd><dt>进程间共享</dt><dd>多个进程可以共享同一份代码库（如.dll, .so），只需在物理内存中保留一份副本，节省空间。</dd><dt>高效进程创建</dt><dd>通过 <mark>写时复制 (COW)</mark> 技术，创建子进程时无需立即复制整个内存空间，速度极快。</dd></dl>`},
    {front:"什么是 <mark>请求式分页</mark>？ 🧠", back:`<dl><dt>核心思想</dt><dd>“懒加载”策略：只有当程序实际访问某个页面时，才将其从硬盘加载到物理内存中。</dd><dt>执行者</dt><dd>称为 <mark>Lazy Swapper</mark>，它在程序启动时不预先加载任何页面。</dd><dt>好处</br><dd>更少的I/O操作，更少的内存需求，更快的响应时间，可支持更多并发用户。</dd></dl>`},
    {front:"什么是 <mark>页错误 (Page Fault)</mark>？ 🚨", back:`<dl><dt>定义</dt><dd>当CPU访问一个在页表中被标记为 <mark>无效 (invalid)</mark> 的页面时，硬件产生的一个 <mark>陷阱 (trap)</mark>。</br><b>注意：</b>这不是程序错误，而是虚拟内存系统工作的正常信号。</dd><dt>处理流程</dt><dd>1. <b>陷入OS</b>：暂停当前进程。<br>2. <b>检查合法性</b>：确认地址是否合法。<br>3. <b>寻找空闲帧</b>：在物理内存中找一个空位。<br>4. <b>从硬盘调页</b>：将所需页面加载到空闲帧。<br>5. <b>重置页表</b>：将页表项更新为有效，并记录物理帧号。<br>6. <b>重启指令</b>：重新执行之前引发错误的指令。</dd></dl>`},
    {front:"什么是 <mark>写时复制 (COW)</mark>？ ✍️", back:`<dl><dt>核心思想</dt><dd>“不要立即复制，等到真正需要写入时再复制”。</dd><dt>应用场景</dt><dd>在 fork() 创建子进程时，父子进程初始共享所有内存页面，并将它们标记为 <mark>只读</mark>。</dd><dt>触发与执行</dt><dd>当任何一方尝试 <mark>写入</mark> 共享页面时，会触发一个页错误。<br>操作系统捕获此错误，为该进程复制一份私有页面副本，并将其标记为 <mark>可写</mark>，然后恢复写入操作。</dd><dt>优点</dt><dd>极大提升了进程创建的效率，避免了大量不必要的内存拷贝。</dd></dl>`},
    {front:"页面置换与 <mark>脏位</mark> 优化 🧼", back:`<dl><dt>问题背景</dt><dd>当发生页错误且 <mark>没有空闲物理帧</mark> 时，必须选择一个当前在内存中的页面（受害者）换出到硬盘，以腾出空间。</dd><dt>基本流程</dt><dd>1. 选择受害者页面。<br>2. 将受害者页面 <mark>写回硬盘</mark>。<br>3. 将新页面换入。<br>4. 更新两个进程的页表。</dd><dt>脏位优化</dt><dd>每个页表项增加一个 <mark>修改位 (Modify/Dirty Bit)</mark>。页面被写入时，硬件将其置1。<br>如果要换出的受害者页面是“干净的”（脏位为0），则 <mark>无需写回</mark> 硬盘，因为它与硬盘上的副本一致，可直接丢弃，从而节省一次耗时的I/O操作。</dd></dl>`},
    {front:"页面置换算法：FIFO, OPT, LRU 🗂️", back:`<dl><dt>FIFO (先进先出)</dt><dd>置换最早进入内存的页面。<br><b>缺点：</b>简单但低效，可能换出重要页面，并存在 <mark>Belady异常</mark>（分配更多帧反而增加页错误）。</dd><dt>OPT (最佳算法)</dt><dd>置换未来最长时间内不会被访问的页面。<br><b>优点：</b>页错误率最低，是理想的性能基准。<br><b>缺点：</b>无法实现，因为无法预知未来。</dd><dt>LRU (最近最少使用)</dt><dd>置换过去最长时间内未被访问的页面。基于局部性原理，是OPT的良好近似。<br><b>缺点：</b>纯粹实现代价高（需硬件支持时间戳或维护栈）。</dd></dl>`},
    {front:"LRU 近似算法 (时钟算法) ⏰", back:`<dl><dt>背景</dt><dd>纯LRU实现复杂，因此采用近似算法。</dd><dt>引用位算法</dt><dd>为每页设置一个 <mark>引用位</mark>，访问时硬件置1。置换时，优先选择引用位为0的页面。</dd><dt>二次机会/时钟算法</dt><dd>这是引用位算法的改进。所有页面组织成 <mark>环形链表</mark>（钟面），一个指针指向当前位置。<br>检查指针所指页面：<br> • 若引用位为 <mark>0</mark>：置换该页。<br> • 若引用位为 <mark>1</mark>：给它“第二次机会”，将其引用位清零，指针前进一步。<br><b>优点：</b>开销小，性能接近LRU，是现代操作系统中的常用选择。</dd></dl>`}
  ]
};