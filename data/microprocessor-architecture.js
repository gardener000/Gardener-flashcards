// data/microprocessor-architecture.js
export default {
  name: "汇编与接口：微处理器体系结构",
  data: [
    {front:"CPU 编程模型的核心是什么？ 🗺️",back:`<dl><dt>核心概念</dt><dd>将CPU视为可编程设备，需了解其 <mark>内部编程模型</mark>（工具）与 <mark>内存寻址方式</mark>（方法）。</dd><dt>三大工作模式</dt><dd><b>实模式 (Real)</b>: DOS时代，简单，1MB限制。<b>保护模式 (Protected)</b>: 现代OS基础，安全，功能强大。<b>平坦模式 (Flat)</b>: 64位模式，内存管理简洁高效。</dd><dt>学习重点</dt><dd>掌握CPU的“工具箱”(<mark>寄存器</mark>)，以及如何在不同“工作模式”下指挥CPU存取数据。</dd></dl>`},
    {front:"CPU 寄存器分几类？ 🧰",back:`<dl><dt>程序可见寄存器 (Visible)</dt><dd>程序员可直接通过指令操作的寄存器，如 <mark>MOV EAX, 10</mark>。好比汽车的 <mark>方向盘、油门</mark>。</dd><dt>程序不可见寄存器 (Invisible)</dt><dd>由操作系统或CPU内部管理的寄存器，应用程序无法直接访问。好比汽车ECU的 <mark>内部参数</mark>。</dd><dt>总结</dt><dd>寄存器分为程序员直接使用的“前台工具”和系统在幕后使用的“后台工具”。</dd></dl>`},
    {front:"32位 (IA-32) vs 64位 CPU 编程模型 🚀",back:`<dl><dt>32位 (IA-32)</dt><dd><b>通用寄存器</b>: 8个 (EAX, EBX...)。<b>指令指针</b>: EIP (32位)。<b>段寄存器</b>: CS, DS等用于分段管理。</dd><dt>64位 (x86-64)</dt><dd><b>通用寄存器</b>: 16个 (RAX, RBX... R8-R15)，<mark>数量翻倍，宽度加倍</mark>。<b>指令指针</b>: RIP (64位)。</dd><dt>共同点</dt><dd>都包含标志寄存器 (EFLAGS/RFLAGS) 和用于多媒体的向量寄存器 (MMX/SSE/AVX)。</dd><dt>核心区别</dt><dd>64位模式下工具更多、尺寸更大，能处理的任务更复杂。</dd></dl>`},
    {front:"通用寄存器 (GPRs) 的“约定”用途？ 📜",back:`<dl><dt>EAX/RAX (Accumulator)</dt><dd>累加器，用于 <mark>算术运算</mark>（特别是乘除）和 <mark>函数返回值</mark>。</dd><dt>ECX/RCX (Counter)</dt><dd>计数器，常用于 <mark>循环</mark>，如 for 循环中的 <mark>i</mark>。</dd><dt>EBX/RBX (Base)</dt><dd>基址寄存器，指向数组或结构的 <mark>起始地址</mark>。</dd><dt>EDX/RDX (Data)</dt><dd>数据寄存器，常作EAX的“副手”，存放乘法结果的 <mark>高位</mark>。</dd><dt>ESP/RSP (Stack Pointer)</dt><dd>栈指针，永远指向 <mark>栈顶</mark>。</dd><dt>EBP/RBP (Base Pointer)</dt><dd>基址指针，标记 <mark>当前栈帧</mark> 的底部，用于访问参数和局部变量。</dd><dt>ESI/RSI & EDI/RDI</dt><dd>源/目标变址寄存器，常用于 <mark>字符串操作</mark>。</dd></dl>`},
    {front:"RAX 寄存器的“套娃”结构是什么？ 🇷🇺",back:`<dl><dt>层级结构</dt><dd>一个大的寄存器可被当作几个小的来用，以实现向后兼容。</dd><dt>具体分层</dt><dd><b>RAX</b> (64位) 包含低32位 <b>EAX</b>。<b>EAX</b> (32位) 包含低16位 <b>AX</b>。<b>AX</b> (16位) 分为高8位 <b>AH</b> 和低8位 <b>AL</b>。</dd><dt>部分寄存器 (Partial)</dt><dd><mark>EAX, AX, AH, AL</mark> 都是RAX的“部分寄存器”，可根据数据大小灵活选用。</dd></dl>`},
    {front:"为什么 EAX 寄存器如此特殊？ ✨",back:`<dl><dt>硬件规定</dt><dd>是 <mark>乘法 (MUL)</mark> 和 <mark>除法 (DIV)</mark> 指令的默认操作数。</dd><dt>编码优势</dt><dd>涉及EAX的指令通常有更短的机器码。例如 <mark>ADD EAX, imm</mark> 比 <mark>ADD EBX, imm</mark> 短一个字节。</dd><dt>性能好处</dt><dd>更短的指令意味着更高的 <mark>代码密度</mark> 和更好的 <mark>缓存友好性 (cache-friendly)</mark>，从而提升执行效率。</dd></dl>`},
    {front:"64位下新增的8位寄存器有哪些？ 🆕",back:`<dl><dt>新增寄存器</dt><dd>在64位模式下，为了能访问更多8位寄存器，引入了 <mark>BPL, SPL, SIL, DIL</mark>。</dd><dt>对应关系</dt><dd>它们分别代表 <mark>BP, SP, SI, DI</mark> 寄存器的 <mark>低8位</mark>。</dd><dt>使用限制</dt><dd>这些新的8位寄存器 <mark>只能在64位模式下使用</mark>。</dd></dl>`},
    {front:"64位模式下部分寄存器的写入规则？ ⚠️",back:`<dl><dt>核心规则</dt><dd>这是一个性能优化的关键点，也是一个易错点。</dd><dt>修改32位寄存器 (如 EAX)</dt><dd>会 <mark>自动将高32位清零</mark>。例如 <mark>MOV EAX, ...</mark> 会使 <mark>RAX[63:32] = 0</mark>。</dd><dt>修改8/16位寄存器 (如 AX, AL)</dt><dd><mark>不会影响</mark> 寄存器中的其他部分。</dd><dt>设计目的</dt><dd>清零高位是为了 <mark>避免伪依赖</mark>（下一张卡片解释），让CPU的乱序执行引擎更高效。</dd></dl>`},
    {front:"什么是“伪依赖” (Partial Register Stall)？ 🐌",back:`<dl><dt>问题根源</dt><dd>现代CPU无法对部分寄存器进行 <mark>重命名</mark>。</dd><dt>糟糕示例</dt><dd>代码混用 <mark>EAX</mark> 和 <mark>AX</mark>。例如在 <mark>IMUL EAX</mark> 后紧跟 <mark>MOV AX, ...</mark>。</dd><dt>CPU行为</dt><dd>由于 <mark>MOV AX</mark> 只是部分修改RAX，CPU为了保证结果正确，必须暂停(<mark>stall</mark>)，等待 <mark>IMUL EAX</mark> 完全结束后才能继续。这就造成了性能损失。</dd><dt>最佳实践</dt><dd>避免混用一个寄存器的不同尺寸，特别是 <mark>AH, BH, CH, DH</mark>。在64位模式下，尽量使用32位或64位指令操作。</dd></dl>`},
    {front:"如何利用写入规则优化代码？ ✅", back:`<dl><dt>切断依赖链</dt><dd>使用 <mark>MOV EAX, ...</mark> 指令会完全重置RAX（高位清零），这会 <mark>切断与之前代码的依赖关系</mark>。</dd><dt>CPU并行执行</dt><dd>CPU的 <mark>乱序执行引擎</mark> 发现依赖链被切断后，可以通过 <mark>寄存器重命名</mark> 将两条无依赖的代码链映射到不同的物理寄存器，从而 <mark>并行执行</-dd><dt>结论</dt><dd>巧妙使用32位指令（如MOV EAX）可以打破伪依赖，充分发挥CPU的并行处理能力，大幅提升性能。</dd></dl>`},
    {front:"特殊用途寄存器有哪些？ 🧭",back:`<dl><dt>RIP (Instruction Pointer)</dt><dd>指令指针，CPU程序的“灵魂”，永远指向 <mark>下一条待执行指令</mark> 的地址。</dd><dt>RSP (Stack Pointer)</dt><dd>栈指针，栈的“管理员”，永远指向 <mark>栈顶</mark>。</dd><dt>RFLAGS (Flags Register)</dt><dd>标志寄存器，CPU的“状态记录员”，记录运算结果的 <mark>状态</mark>（如是否为零、有无进位）。</dd></dl>`}
    // ... 后续章节的卡片可以继续添加在这里 ...
  ]
};
