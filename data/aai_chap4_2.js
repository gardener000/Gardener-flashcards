// data/aai_chap4_2.js
export default {
  name: "aai_chap4-2：特殊数据传送指令",
  data: [
    {front:"<mark>LEA</mark> (Load Effective Address) 的核心作用 🔑",back:`<dl><dt>指令</dt><dd><mark>LEA reg, [mem]</mark> (加载近指针)。</dd><dt>作用</dt><dd>只执行地址计算：将 <mark>[mem]</mark> (如 $\\text{[EBX + 8*EAX + 4]}$) 的 <mark>有效地址本身</mark> 加载到 <mark>reg</mark> 寄存器中，不访问内存。</dd><dt>与 MOV 的区别 (以取值/取址为例)</dt><dd>$\\text{MOV EDX, [mem]}$ $\\to$ <mark>取内存内容 (value)</mark>，即 $\\text{EDX} = \\text{mem}$ 指向的值。<br>$\\text{LEA ESI, [mem]}$ $\\to$ <mark>取地址 (address)</mark>，即 $\\text{ESI} = \\text{mem}$ 的地址。</dd></dl>`},
    {front:"LEA 的 <mark>奇妙妙用</mark> (算术运算) ➕",back:`<dl><dt>原理</dt><dd>利用 $\\text{CPU}$ 的 <mark>地址计算单元</mark> (比 $\\text{ALU}$ 更快、且不影响标志位)。</dd><dt>算术运算</dt><dd>可高效执行 $\\text{reg} = \\text{reg}_1 + \\text{reg}_2 \\times \\text{scale} + \\text{disp}$ 形式的计算。</dd><dt>示例</dt><dd>$\\text{LEA EAX, [EBX + ECX*4]}$ 实际上执行了 $\\text{EAX} = \\text{EBX} + \\text{ECX} \\times 4$ 的计算。</dd><dt>LEA vs OFFSET</dt><dd><mark>OFFSET</mark> 是 <mark>编译时</mark> 伪操作，只能获取静态标签地址。<br><mark>LEA</mark> 是 <mark>运行时</mark> $\\text{CPU}$ 指令，可计算 <mark>动态地址</mark> (涉及寄存器)。</dd></dl>`},
    {front:"<mark>LDS/LES/LFS/LGS/LSS</mark> (加载远指针) 🗺️",back:`<dl><dt>指令家族</dt><dd>一次性从内存加载一个 <mark>远指针</mark> (段选择子 $\\text{+}$ 偏移地址)。</dd><dt>LDS reg, mem</dt><dd>从 $\\text{mem}$ 处读取 <mark>偏移地址</mark> 到 $\\text{reg}$；读取 <mark>段地址</mark> 到 $\\text{DS}$。</dd><dt>应用场景</dt><dd>高级操作，如在操作系统内核或多任务环境中 <mark>切换堆栈</mark> ($\text{LSS SP, SADDR}$ 快速加载新的 $\\text{SS:SP}$)。</dd></dl>`},
    {front:"字符串指令 <mark>MOVS/LODS/STOS</mark> 核心机制 🧱",back:`<dl><dt>MOVS (Move String)</dt><dd>内存 $\\to$ 内存复制：从 $\\text{DS:SI}$ 复制到 <mark>ES:DI</mark>。<br>用途：高效 <mark>内存块复制</mark> ($\text{memcpy}$)。</dd><dt>LODS (Load String)</dt><dd>内存 $\\to$ 累加器：从 $\\text{DS:SI}$ 加载到 <mark>AL/AX/EAX/RAX</mark>。<br>用途：配合其他指令实现扫描。</dd><dt>STOS (Store String)</dt><dd>累加器 $\\to$ 内存：从 $\\text{AL/AX/EAX/RAX}$ 存储到 <mark>ES:DI</mark>。<br>用途：高效 <mark>内存填充</mark> ($\text{memset}$)。</dd></dl>`},
    {front:"字符串指令的 <mark>自动更新</mark> 与 <mark>REP</mark> 前缀 🔁",back:`<dl><dt>自动更新</dt><dd>每执行一次，<mark>SI/DI</mark> 自动增/减步长 (步长取决于操作数大小：$\\text{B=1, W=2, D=4}$ 等)。</dd><dt>方向标志位 (DF)</dt><dd><mark>DF=0 (CLD)</mark> $\\to$ 指针 <mark>递增</mark> (从低地址向高地址)。<br><mark>DF=1 (STD)</mark> $\\to$ 指针 <mark>递减</mark> (从高地址向低地址)。</dd><dt>REP 前缀</dt><dd>与 $\\text{STOS/MOVS}$ 结合，重复执行指令直到 <mark>CX/ECX/RCX}$ 变为 $\\text{0}$，效率远高于手写 <mark>LOOP</mark> 循环 (硬件微码实现)。</dd></dl>`},
    {front:"MOVS <mark>重叠区域复制</mark> 规则 ⚠️",back:`<dl><dt>场景</dt><dd>源区域和目的区域有重叠 (如 $\\text{copy(100, 105, 10)}$)。</dd><dt>目的地址 $>$ 源地址 (向后移动)</dt><dd>必须使用 <mark>STD (DF=1)</mark>，从 <mark>尾部</mark> 开始复制 (保证源数据未被覆盖)。</dd><dt>目的地址 $<$ 源地址 (向前移动)</dt><dd>必须使用 <mark>CLD (DF=0)</mark>，从 <mark>头部</mark> 开始复制。</dd></dl>`},
    {front:"<mark>XCHG</mark> (Exchange) 与 <mark>XLAT</mark> (Translate) 🔄",back:`<dl><dt>XCHG</dt><dd>交换两个操作数内容 (e.g., $\\text{XCHG EAX, EBX}$)。<br>与内存操作数一起使用时，自动 <mark>锁总线 (bus lock)</mark>，用于实现多线程 <mark>原子操作</mark> (无锁数据结构)。</dd><dt>XLAT</dt><dd>查表转换 (<mark>table lookup</mark>) 指令。 <br>工作原理：$\\text{AL} = \\text{[BX} + \\text{AL]}$ 或 $\\text{[EBX} + \\text{AL]}$。用 $\\text{AL}$ 中的值作为 $\\text{BX}$ 指向的 <mark>转换表索引</mark>，获取对应字节替换 $\\text{AL}$。</dd></dl>`},
    {front:"<mark>MOVSX/MOVZX</mark> 与 <mark>BSWAP</mark> (大小端) 🧩",back:`<dl><dt>MOVZX (Zero-Extend)</dt><dd><mark>零扩展</mark> 移动。将较小操作数复制到较大寄存器低位，高位 <mark>全部清 $\\text{0}$</mark>。适用于 <mark>无符号数</mark>。</dd><dt>MOVSX (Sign-Extend)</dt><dd><mark>符号扩展</mark> 移动。将高位用源操作数的 <mark>符号位</mark> 填充。适用于 <mark>有符号数</mark>。</dd><dt>BSWAP (Byte Swap)</dt><dd>反转 <mark>32/64 位寄存器</mark> 中字节顺序。主要用于处理 <mark>大小端 (Endian Conversion)</mark> 差异 (e.g., 网络协议数据) 或 $\\text{Big-Endian}$ 文件。</dd></dl>`},
    {front:"<mark>CMOV</mark> (Conditional Move) 性能优化 💨",back:`<dl><dt>指令家族</dt><dd>将 <mark>条件判断</mark> 和 <mark>数据移动</mark> 合并为一条指令 (e.g., $\\text{CMOVE}$：相等则移动)。</dd><dt>优势</dt><dd>依赖 <mark>EFLAGS</mark> 标志位状态，<mark>避免了分支跳转</mark>。这消除了 <mark>分支预测失败</mark> 带来的流水线清空和重建惩罚，大幅提升现代 $\\text{CPU}$ 的性能。</dd></dl>`}
  ]
};
