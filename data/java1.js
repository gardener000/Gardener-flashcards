// data/java-review.js
export default {
  name: "Java：接口、枚举与继承",
  data: [
    {front:"`interface` 的核心特性是什么？ 🧩",back:`<dl><dt>本质</dt><dd>一种行为规范或契约，定义了类应该做什么（<mark>what</mark>），但不关心怎么做（<mark>how</mark>）。</dd><dt>成员</dt><dd>主要包含 <mark>全局常量</mark> (public static final) 和 <mark>抽象方法</mark> (public abstract)。Java 8+ 增加了默认方法和静态方法。</dd><dt>限制</dt><dd>不能被实例化 (不能用 <mark>new</mark>)，因此没有 <mark>构造方法</mark>。</dd><dt>多态</dt><dd>可以作为变量类型，实现多态。例如: <mark>List&lt;String&gt; list = new ArrayList&lt;&gt;();</mark></dd></dl>`},
    {front:"`implements` vs `extends` 有何区别？ 🔗",back:`<dl><dt>extends (继承)</dt><dd>用于 <mark>类与类</mark> (单继承) 或 <mark>接口与接口</mark> (多继承) 之间。体现 "is-a" 的关系。</dd><dt>implements (实现)</dt><dd>用于 <mark>类与接口</mark> 之间，一个类可以实现多个接口。体现 "can-do" 的能力。</dd><dt>语法规则</dt><dd>一个类定义时，<mark>extends</mark> 必须在 <mark>implements</mark> 之前。<br><code>class MyClass extends Base implements I1, I2 {}</code></dd></dl>`},
    {front:"接口成员有哪些“潜规则”？ 📜",back:`<dl><dt>字段 (Fields)</dt><dd>任何定义的字段都隐式地是 <mark>public static final</mark>，即全局常量。必须在声明时初始化。</dd><dt>方法 (Methods)</dt><dd>在 Java 8 之前，所有方法都隐式地是 <mark>public abstract</mark>。</dd><dt>修饰符</dt><dd>顶层接口只能是 <mark>public</mark> 或包私有 (默认)，不允许 <mark>private</mark> 或 <mark>protected</mark>。</dd></dl>`},
    {front:"如何使用 `Comparable` 接口？ ⚖️",back:`<dl><dt>目的</dt><dd>让一个类的对象拥有 <mark>可比较</mark> 的能力，通常用于排序。</dd><dt>核心方法</dt><dd>必须实现 <code>int compareTo(T o)</code> 方法。</dd><dt>返回值约定</dt><dd> • 返回 <mark>正数</mark>: <code>this</code> 对象 > 参数 <code>o</code><br> • 返回 <mark>负数</mark>: <code>this</code> 对象 < <code>o</code><br> • 返回 <mark>零</mark>: <code>this</code> 对象 == <code>o</code></dd><dt>应用</dt><dd>在作业中，通过比较两个<code>ComparableCircle</code>对象的面积 (<code>getArea()</code>) 来决定大小。</dd></dl>`},
    {front:"`Enum` (枚举) 是什么？ 🎨",back:`<dl><dt>本质</dt><dd>一种特殊的 <mark>类</mark>，它限制变量只能取预先定义好的一组常量值。</dd><dt>优点</dt><dd>提供了 <mark>类型安全</mark>，比用字符串或整数常量更清晰、更安全。</dd><dt>底层</dt><dd>每个枚举类型都隐式地继承自 <code>java.lang.Enum</code> 类。</dd><dt>常见用途</dt><dd>定义星期、颜色、状态码等固定集合。</dd></dl>`},
    {front:"枚举有哪些关键方法与限制？ 🚫",back:`<dl><dt>关键方法</dt><dd>编译器自动生成 <mark>values()</mark> 方法，可以返回包含所有枚举实例的数组。</dd><dt>限制 1</dt><dd>枚举常量是在编译时确定的，不能在运行时 <mark>动态添加或删除</mark>。</dd><dt>限制 2</dt><dd>不能在 <mark>方法内部</mark> 定义枚举类型。</dd><dt>限制 3</dt><dd>不能使用 <mark>extends</mark> 关键字继承其他类，因为它已经继承了 <code>Enum</code>。</dd></dl>`},
    {front:"方法重载 (Overloading) 的规则是什么？ ⚙️",back:`<dl><dt>定义</dt><dd>在同一个类中，允许存在一个以上的同名方法。</dd><dt>核心规则</dt><dd>方法名必须相同，但 <mark>参数列表必须不同</mark> (参数的类型、个数或顺序不同)。</dd><dt>易错点</dt><dd>方法的 <mark>返回类型不同</mark> 不足以构成重载。如果只有返回类型不同，会导致 <mark>编译错误</mark>。</dd></dl>`},
    {front:"继承与实现中的可见性陷阱 👁️",back:`<dl><dt>问题描述</dt><dd>当一个类实现一个接口时，它实现的方法的 <mark>可见性不能低于</mark> 接口中定义的可见性。</dd><dt>原因</dt><dd>接口中的方法默认是 <mark>public</mark> 的。</dd><dt>错误示例</dt><dd>如果在实现类中，不写访问修饰符，方法会变成默认的包私有 (package-private)，这比 <mark>public</mark> 权限低，导致 <mark>编译失败</mark>。</dd><dt>正确做法</dt><dd>实现接口方法时，必须明确地使用 <mark>public</mark> 关键字。</dd></dl>`},
    {front:"小结 ✅",back:`<dl><dt>接口 (Interface)</dt><dd>定义 <mark>行为契约</mark>，支持多实现，是多态的重要基石。</dd><dt>枚举 (Enum)</dt><dd>提供 <mark>类型安全</mark> 的常量集合，本质是特殊的类。</dd><dt>继承 (Inheritance)</dt><dd>代码复用，建立 "is-a" 层次结构，Java只支持 <mark>单继承</mark>。</dd><dt>规则</dt><dd>一个类可以 <mark>继承一个父类</mark> 的同时 <mark>实现多个接口</mark>，这是Java结合继承和组合优势的方式。</dd></dl>`}
  ]
};