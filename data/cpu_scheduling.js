// data/cpu_scheduling.js
export default {
  name: "操作系统：CPU调度算法",
  data: [
    {front:"CPU调度的<mark>核心目标</mark>与<mark>基本模式</mark>是什么？ 🎯", back:"<dl><dt>核心目标</dt><dd>最大化CPU利用率 (<mark>Maximum CPU utilization</mark>)，避免CPU空闲浪费。</dd><dt>产生背景</dt><dd>在<mark>多道程序设计 (multiprogramming)</mark> 环境下，当一个进程等待I/O时，系统可将CPU切换给另一就绪进程。</dd><dt>基本模式</dt><dd>程序执行是 <mark>CPU突发 (CPU burst)</mark> 和 <mark>I/O突发 (I/O burst)</mark> 交替的周期。</dd></dl>"},
    {front:"衡量调度算法好坏的<mark>五大准则</mark>是什么？ 📊", back:"<dl><dt>CPU利用率 (Utilization)</dt><dd>CPU“忙碌”时间占比，越高越好。</dd><dt>吞吐量 (Throughput)</dt><dd>单位时间内完成的进程数，越多越好。</dd><dt>周转时间 (Turnaround Time)</dt><dd>从提交到完成的总时间，越短越好。</dd><dt>等待时间 (Waiting Time)</dt><dd>在就绪队列中排队的时间，越短越好。</dd><dt>响应时间 (Response Time)</dt><dd>从请求到首次响应的时间，越短越好（尤其对交互系统）。</dd></dl>"},
    {front:"<mark>抢占式</mark> 与 <mark>非抢占式</mark> 调度有何区别？ ⚔️", back:"<dl><dt>非抢占式 (Nonpreemptive)</dt><dd>一旦进程获得CPU，会一直运行直到自己主动放弃（完成或等待I/O）。<br>比喻：你在KTV唱歌，只要歌没完或你没主动切，谁也抢不走麦克风。</dd><dt>抢占式 (Preemptive)</dt><dd>操作系统可以强制“抢走”当前运行进程的CPU，分配给更高优先级的进程。<br>比喻：你在玩游戏，妈妈过来直接关机让你写作业。</dd></dl>"},
    {front:"<mark>调度程序</mark> 与 <mark>分派程序</mark> 的角色？ 📜", back:"<dl><dt>调度程序 (Scheduler)</dt><dd><b>决策者</b>：从就绪队列中选择下一个要运行的进程。</dd><dt>分派程序 (Dispatcher)</dt><dd><b>执行者</b>：将CPU控制权交给调度程序选中的进程。<br>工作包括：上下文切换、切换到用户模式、跳转到程序正确位置。</dd><dt>分派延迟 (Dispatch Latency)</dt><dd>分派程序完成切换所需时间，是一种系统开销。</dd></dl>"},
    {front:"先来先服务算法 <mark>(FCFS)</mark> 及其<mark>致命缺点</mark>？ 🚶‍♂️➡️🚶‍♀️", back:"<dl><dt>核心思想</dt><dd>按进程到达就绪队列的顺序进行调度，实现简单公平。</dd><dt>性质</dt><dd>非抢占式。</dd><dt>致命缺点</dt><dd><mark>护航效应 (Convoy Effect)</mark>：一个长进程（大卡车）会阻塞后面所有短进程（小汽车），导致平均等待时间很长，系统效率低下。</dd></dl>"},
    {front:"最短作业优先算法 <mark>(SJF)</mark> 的<mark>核心思想</mark>与<mark>难题</mark>？ ⚡️", back:"<dl><dt>核心思想</dt><dd>选择下一个CPU突发时间最短的进程来执行。理论上可证明其<mark>平均等待时间最短</mark>。</dd><dt>模式</dt><dd>分为<mark>非抢占式SJF</mark>和<mark>抢占式SJF</mark>（也称最短剩余时间优先SRTF）。</dd><dt>最大难题</dt><dd>无法精确知道进程<mark>下一个CPU突发的时长</mark>。</dd><dt>解决方案</dt><dd>通过<mark>指数平均法</mark>根据历史数据进行预测。</dd><dt>潜在问题</dt><dd>可能导致长进程<mark>饥饿 (Starvation)</mark>。</dd></dl>"},
    {front:"<mark>优先级调度</mark> 及其关键问题如何解决？ 👑", back:"<dl><dt>核心思想</dt><dd>为每个进程分配一个优先级，CPU总是分配给优先级最高的进程。（SJF是其特例）</dd><dt>关键问题</dt><dd><mark>饥饿 (Starvation)</mark>：低优先级进程可能永远得不到执行。</dd><dt>解决方案</dt><dd><mark>老化 (Aging)</mark>：逐步提升长时间等待的进程的优先级，防止其被饿死。</dd></dl>"},
    {front:"轮转调度算法 <mark>(RR)</mark> 的工作原理是什么？ 🎡", back:"<dl><dt>核心思想</dt><dd>专门为<mark>分时系统</mark>设计，公平地为每个进程分配一小段CPU时间，称为<mark>时间片 (Time Quantum)</mark>。</dd><dt>执行过程</dt><dd>进程运行一个时间片后，若未完成则被中断，移至就绪队列末尾，等待下一轮。</dd><dt>性质</dt><dd>抢占式。</dd><dt>性能权衡</dt><dd>时间片太大则退化为FCFS；太小则上下文切换开销过大。<br>优点：<mark>响应时间短</mark>，公平。缺点：平均周转时间较长。</dd></dl>"},
    {front:"<mark>多级队列</mark> 与 <mark>多级反馈队列</mark> 有何不同？ 📂", back:"<dl><dt>多级队列 (Multilevel Queue)</dt><dd>将就绪队列划分为多个独立队列（如前台、后台），每个队列使用不同算法。<br><b>缺点</b>：进程被永久分配到一个队列，不够灵活。</dd><dt>多级反馈队列 (MLFQ)</dt><dd>允许进程在队列之间移动。根据进程行为动态调整其优先级。<br><b>机制</b>：CPU密集型进程会被<mark>降级</b >到低优先级队列，I/O密集型或长时间等待的进程会被<mark>升级</b >。<br><b>优点</b>：最通用、最复杂的算法，能平衡各种需求。</dd></dl>"},
    {front:"<mark>多处理器调度</mark>需要考虑哪些核心问题？ 💻💻", back:"<dl><dt>调度方式</dt><dd><b>非对称(AMP)</b>：一个主处理器负责调度；<b>对称(SMP)</b>：每个处理器自我调度（主流）。</dd><dt>处理器亲和性 (Affinity)</dt><dd>尽量让进程在同一个CPU上运行，以利用其高速缓存(cache)。</dd><dt>负载均衡 (Load Balancing)</dt><dd>确保所有CPU的工作负载均匀，避免有的CPU闲置而有的过载。</dd><dt>核心矛盾</dt><dd>负载均衡可能会破坏处理器亲和性，需要在两者之间权衡。</dd></dl>"},
    {front:"<mark>实时调度</mark> 与普通调度的根本区别是什么？ ⏰", back:"<dl><dt>核心目标</dt><dd>满足任务的<mark>截止时间 (Deadline)</mark>，可预测性比高吞吐量更重要。</dd><dt>分类</dt><dd><b>硬实时</b>：必须满足截止时间，否则系统失败（如安全气囊）。<b>软实时</b>：尽力满足，偶尔错过可接受（如视频播放）。</dd><dt>主要挑战</dt><dd><mark>优先级反转 (Priority Inversion)</mark>：高优先级任务被低优先级任务阻塞，需要用<mark>优先级继承</mark>等协议解决。</dd></dl>"},
    {front:"如何科学地<mark>评估</mark>调度算法的性能？ 🧪", back:"<dl><dt>确定性建模</dt><dd>给定特定工作负载，计算性能指标。简单但局限。</dd><dt>排队模型</dt><dd>利用数学公式进行理论分析。通用但基于假设。</dd><dt>模拟 (Simulation)</dt><dd>编写程序模拟系统行为，使用真实系统的<mark>轨迹磁带 (trace tape)</mark>作为输入。灵活且较准确。</dd><dt>实现 (Implementation)</dt><dd>在真实操作系统内核中实现算法并测量。最准确但成本和风险最高。</dd></dl>"}
  ]
};