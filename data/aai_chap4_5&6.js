// data/aai_chap4-5&6.js
export default {
  name: "aai_chap4-5&6：汇编器细节与内存模型",
  data: [
    {front:"<mark>段重载前缀</mark> (Segment Override Prefix) 的作用 🎯",back:`<dl><dt>作用</dt><dd>一个 <mark>单字节机器码</mark>，放在指令前，<mark>临时改变</mark> 当前指令访问内存时使用的 <mark>默认段寄存器</mark>。</dd><dt>默认规则回顾</dt><dd><mark>数据</mark> (BX, SI, DI 寻址) 默认 <mark>DS</mark>。<br><mark>堆栈</mark> (BP, SP 寻址) 默认 <mark>SS</mark>。<br><mark>串操作目的地址</mark> ($\text{DI}$ 寻址) 默认 <mark>ES</mark>。</dd><dt>语法与有效性</dt><dd>语法：<mark>SEGMENT: [Offset]</mark> (e.g., $\\text{MOV AX, ES:[BX]}$)。<br>有效：<mark>只对紧随其后的一条指令</mark> 有效。</dd><dt>限制</dt><dd>不能重载 <mark>修改指令流</mark> 的指令 (e.g., $\\text{JMP}, \\text{CALL}$ 的 $\\text{CS}$ 寄存器)。</dd></dl>`},
    {front:"指令 (Instruction) vs <mark>伪指令</mark> (Directive) ⚙️",back:`<dl><dt>指令 (Instruction)</dt><dd>给 <mark>CPU</mark> 看的，<mark>运行时</mark> 执行具体操作 ($\text{MOV}, \\text{ADD}$)。<br>结果：被翻译成 <mark>机器码</mark> (0和1)。</dd><dt>伪指令 (Directive)</dt><dd>给 <mark>汇编器</mark> 看的，<mark>汇编时</mark> 指导如何生成代码、分配内存、定义符号 ($\text{DB}, \\text{PROC}, \\text{.MODEL}$)。<br>结果：<mark>本身不产生机器码</mark>，仅控制汇编过程或定义数据。</dd></dl>`},
    {front:"数据定义伪指令 (<mark>DB, DW, DD</mark>) 💾",back:`<dl><dt>作用</dt><dd>在数据段中 <mark>分配空间</mark> 并 <mark>初始化变量</mark>。标签名隐含了 <mark>地址</mark> 和 <mark>类型</mark> (大小)。</dd><dt>常用类型</dt><dd><mark>DB</mark> (Define Byte): 8位，<mark>DW</mark> (Define Word): 16位，<mark>DD</mark> (Define Doubleword): 32位。</dd><dt>DUP 伪指令</dt><dd><mark>count DUP (value)</mark>：重复定义某个值或未初始化的空间 (e.g., $\\text{DB 100 DUP(?)}$, 定义 $\\text{100}$ 个未初始化字节)。</dd><dt>? (问号)</dt><dd>表示只 <mark>预留空间</mark>，不指定初始值，初始内容是 <mark>不确定的</mark>。</dd></dl>`},
    {front:"<mark>EQU</mark> 和 <mark>THIS</mark> 伪指令 🔖",back:`<dl><dt>EQU (Equate)</dt><dd>功能：定义 <mark>常量</mark>，将符号名与数值或表达式 <mark>等价</mark> (e.g., $\\text{TEN EQU 10}$)。<br>特点：EQU 定义的常量 <mark>不能被重新定义</mark> (与 $\\text{=}$ 区分)。<br>优点：提高 <mark>可读性</mark> 和 <mark>简化维护</mark>。</dd><dt>THIS</dt><dd>功能：在 <mark>同一个内存地址</mark> 上创建 <mark>不同类型</mark> 的 <mark>别名标签</mark>。<br>应用：解决 <mark>类型错配</mark> 问题，允许用 <mark>字节类型</mark> 的标签访问 <mark>字类型</mark> 数组中的单个字节 (e.g., $\\text{ByteArray THIS BYTE}$)。</dd></dl>`},
    {front:"内存组织控制：<mark>ORG</mark> 和 <mark>ALIGN</mark> 伪指令 🧱",back:`<dl><dt>ORG (Origin)</dt><dd>功能：<mark>强制改变</mark> 汇编器的 <mark>位置计数器</mark> 的值，让接下来的代码/数据从一个 <mark>指定的绝对偏移地址</mark> 开始存放 (e.g., $\\text{ORG 7C00h}$ 用于引导扇区)。</dd><dt>ALIGN (Align)</dt><dd>功能：强制汇编器将下一个数据或指令放置在 <mark>特定的地址边界</mark> (2, 4, 8, 16的倍数) 上。</dd><dt>对齐必要性</dt><dd>CPU 通常一次性读取一个数据块。如果数据 <mark>未对齐</mark>，会 <mark>跨越</mark> 两个内存块边界，导致 $\\text{CPU}$ 需要 <mark>两次内存访问</mark> 和 <mark>额外的移位拼接</mark> 操作，降低性能。</dd></dl>`},
    {front:"<mark>PROC/ENDP</mark> 与 <mark>MACRO/ENDM</mark> 过程复用 🔁",back:`<dl><dt>过程 (Procedure)</dt><dd>用 $\\text{PROC/ENDP}$ 定义。代码 <mark>只有一份</mark>，每次调用 ($\text{CALL}$ 指令) 涉及 <mark>压栈、跳转</mark>，有 <mark>性能开销</mark>。</dd><dt>宏 (Macro)</dt><dd>用 $\\text{MACRO/ENDM}$ 定义。没有独立代码体，每次调用在 <mark>汇编时</mark> 被 <mark>内联展开</mark> (<mark>复制粘贴</mark>) 到调用处。</dd><dt>选择</dt><dd>宏 <mark>速度快</mark> (无 $\\text{CALL/RET}$ 开销)，但会导致 <mark>代码膨胀</mark>。<br>过程 <mark>代码紧凑</mark>，适用于复杂/长代码块。</dd></dl>`},
    {front:"内存模型 (<mark>.MODEL</mark>) 与 <mark>平坦模型</mark> 🏠",back:`<dl><dt>作用</dt><dd>MASM 提供的 <mark>简化抽象</mark> 机制，通过选择模型 (tiny, small, large 等) 自动设置段寄存器的使用规则和 <mark>指针的默认大小</mark> (near/far)。</dd><dt>选择原则</dt><dd>选择 <mark>能满足需求的最小模型</mark>，因为 <mark>near</mark> (近指针，只含偏移) 比 <mark>far</mark> (远指针，含段+偏移) 更快、更紧凑。</dd><dt>Flat Model (平坦模型)</dt><dd>现代 32/64 位操作系统的主流模型。所有 <mark>段寄存器指向同一个巨大的地址空间</mark> (没有分段概念)，<mark>所有指针</mark> 都是 <mark>近指针</mark> ($\text{32/64}$ 位偏移)。</dd><dt>完整段定义</dt><dd>使用 $\\text{SEGMENT/ENDS/ASSUME}$ 手动精确控制每个段的 <mark>属性</mark> (readonly, use32, class 等)，适用于 <mark>操作系统内核</mark> 等复杂程序。</dd></dl>`}
  ]
};