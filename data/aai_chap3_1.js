// data/addressing_modes.js
export default {
  name: "汇编Chap3:寻址方式（上）",
  data: [
    {front:"寻址方式的 <mark>核心基础</mark> 🧠",back:`<dl><dt>Address Size (地址大小)</dt><dd>决定 $\\text{CPU}$ 可访问的<mark>内存范围</mark> (e.g., 32位 $\\to$ 4GB)。</dd><dt>Operand Size (操作数大小)</dt><dd>决定指令一次处理的<mark>数据宽度</mark> (8/16/32位)。</dd><dt>64位模式默认</dt><dd>Address Size 默认 <mark>64位</mark>；Operand Size 默认 <mark>32位</mark> (为兼容32位代码)。</dd><dt>寻址方式分类</dt><dd><mark>数据寻址</mark> (MOV, ADD), <mark>栈内存寻址</mark> (PUSH, POP), <mark>程序内存寻址</mark> (JMP, CALL)。</dd></dl>`},
    {front:"汇编指令 <mark>基本结构</mark> 与 <mark>数据流向</mark> ➡️",back:`<dl><dt>四字段结构</dt><dd><mark>标签</mark> (Label), <mark>操作码</mark> (Opcode), <mark>操作数</mark> (Operands), <mark>注释</mark> (Comment)。</dd><dt>MOV 指令</dt><dd>格式：$\text{MOV Destination, Source}$。数据从 <mark>Source</mark> 复制到 <mark>Destination</mark>。</dd><dt>Intel 语法流向</dt><dd>数据流向为 <mark>右 $\\to$ 左</mark> (e.g., MOV AX, BX: BX内容复制到AX)。</dd><dt>AT&T 语法流向</dt><dd>数据流向为 <mark>左 $\\to$ 右</mark> (e.g., movl %ebx, %eax)。</dd></dl>`},
    {front:"<mark>寄存器寻址</mark> (Register Addressing) 🚀",back:`<dl><dt>特点与优势</dt><dd>数据在 <mark>CPU 内部寄存器</mark> 中，速度 <mark>极快</mark>，几乎无延迟。</dd><dt>关键规则</dt><dd><mark>源操作数</mark> 和 <mark>目的操作数</mark> 的大小必须 <mark>完全一致</mark> (e.g., MOV EAX, BX 会报错)。</dd><dt>执行效果</dt><dd>源寄存器内容不变；目的寄存器内容被 <mark>覆盖</mark> (MOV 是复制操作)。</dd></dl>`},
    {front:"<mark>立即数寻址</mark> (Immediate Addressing) 🔢",back:`<dl><dt>特点</dt><dd>操作数是一个<mark>常数值</mark> (常量)，直接编码在 <mark>指令本身</mark> 中。</dd><dt>限制</dt><dd>立即数只能作为 <mark>源操作数</mark> (Source)。 (e.g., MOV 1234H, AX 是非法的)。</dd><dt>十六进制书写 (MASM)</dt><dd>以 H 结尾 (e.g., 3456H)。若以字母 A-F 开头，必须加前导 <mark>0</mark> (e.g., 0F2H)。</dd><dt>字节序 (Little-Endian)</dt><dd>MOV AX, 'AB' $\\to$ 'B' (42H) 存入 <mark>AL (低字节)</mark>，'A' (41H) 存入 <mark>AH (高字节)</mark>。</dd></dl>`},
    {front:"内存寻址 <mark>万能公式</mark> 与 <mark>直接寻址</mark> 📍",back:`<dl><dt>核心</dt><dd>有效地址 (EA) 是操作数相对于 <mark>段基址</mark> 的 <mark>偏移量</mark> (Offset Address)。</dd><dt>万能公式</dt><dd>$\\text{EA} = \\text{Base} + (\\text{Scale} \\times \\text{Index}) + \\text{Displacement}$</dd><dt>直接寻址 (Direct)</dt><dd>仅使用 <mark>位移量 (Displacement)</mark>。地址是 <mark>固定的</mark> 常数。</dd><dt>狭义直接寻址</dt><dd>特指 $\\text{MOV}$ 指令在 <mark>累加器</mark> (AL/AX/EAX) 与固定内存地址间传送数据 (更短、更快，历史兼容性)。</dd></dl>`},
    {front:"<mark>寄存器间接寻址</mark> (Register Indirect) & 段规则 🧱",back:`<dl><dt>公式</dt><dd>仅使用 <mark>Base</mark> (基址寄存器)。EA = Base。</dd><dt>特点</dt><dd>有效地址存放在 <mark>寄存器</mark> 中 (动态地址)，适用于 <mark>顺序访问数组</mark> 或表格。</dd><dt>默认段 DS</dt><dd>当寻址寄存器为 <mark>BX, SI, DI</mark> (及其扩展) 时，默认关联 <mark>数据段 (DS)</mark>。</dd><dt>默认段 SS</dt><dd>当寻址寄存器为 <mark>BP, SP</mark> (及其扩展) 时，默认关联 <mark>堆栈段 (SS)</mark> (访问栈上局部变量)。</dd></dl>`},
    {front:"内存操作的 <mark>尺寸指示符</mark> (Size Directives) 📐",back:`<dl><dt>问题</dt><dd>当内存操作数没有寄存器提供尺寸信息时 (如 $\\text{MOV [DI], 10H}$)，汇编器 <mark>无法确定</mark> 操作数大小 (8/16/32位)。</dd><dt>解决方案</dt><dd>使用 <mark>指针指示符 (Pointer Directive)</mark> 明确内存单元大小。</dd><dt>常用指示符</dt><dd><mark>BYTE PTR</mark> (8位), <mark>WORD PTR</mark> (16位), <mark>DWORD PTR</mark> (32位)。</dd><dt>正确示例</dt><dd>$\text{MOV}$ <mark>WORD PTR</mark> $\text{[DI], 10H}$ (告诉汇编器写入一个字，即 16 位数据)。</dd></dl>`},
    {front:"<mark>基址加变址寻址</mark> (Base-Plus-Index) 📦",back:`<dl><dt>公式</dt><dd>$\\text{EA} = \\text{Base} + \\text{Index}$。</dd><dt>用途</dt><dd>高效访问 <mark>一维数组</mark> 的 <mark>元素</mark> (如 $\\text{array[index]}$)。</dd><dt>分工</dt><dd><mark>Base</mark> 寄存器存 <mark>数组起始地址</mark> (基地址)。<br><mark>Index</mark> 寄存器存 <mark>元素索引/偏移量</mark> (变址)。</dd><dt>C 语言对应</dt><dd>$\\text{return buf[index];}$</dd></dl>`},
    {front:"<mark>寄存器相对寻址</mark> (Register Relative) 📏",back:`<dl><dt>公式</dt><dd>$\\text{EA} = \\text{Register} + \\text{Displacement}$。</dd><dt>用途</dt><dd>高效访问 <mark>结构体 (Structure)</mark> 的 <mark>成员</mark>。</dd><dt>分工</dt><dd><mark>Register</mark> (Base) 存 <mark>结构体指针</mark> (起始地址)。<br><mark>Displacement</mark> 存 <mark>成员相对于结构体开头的偏移量</mark> (固定常数)。</dd><dt>C 语言对应</dt><dd>$\\text{return foobar->b;}$</dd></dl>`}
  ]
};