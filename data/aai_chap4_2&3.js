// data/aai_chap4_2.js
export default {
  name: "aai_chap4-2&3：特殊数据传送指令",
  data: [
    {front:"<mark>LEA</mark> (Load Effective Address) 的核心作用 💡",back:`<dl><dt>指令作用</dt><dd><mark>只计算</mark> 内存操作数的 <mark>有效地址 (EA)</mark>，然后把这个地址本身 (<mark>Offset</mark>) 存入寄存器。</dd><dt>与 MOV 的本质区别</dt><dd>MOV reg, [mem] $\\to$ <mark>取内容</mark> (Value)<br>LEA reg, [mem] $\\to$ <mark>取地址</mark> (Address)</dd><dt>LEAX 妙用</dt><dd>利用 CPU 的 <mark>地址计算单元</mark> 高效执行算术运算 (e.g., $\\text{LEA EAX, [EBX + ECX*4]}$)，且 <mark>不影响标志位</mark> (Flags)。</dd></dl>`},
    {front:"LEA vs <mark>OFFSET</mark> 伪操作 🆚",back:`<dl><dt>OFFSET (伪操作)</dt><dd><mark>编译时</mark> 被替换成 <mark>静态标签</mark> 的偏移地址常数 (e.g., $\\text{MOV BX, OFFSET LIST}$)。<br><mark>效率更高</mark> (更快)。</dd><dt>LEA (CPU 指令)</dt><dd><mark>运行时</mark> 动态计算 <mark>复杂地址</mark> (涉及寄存器，e.g., $\\text{LEA SI, [BX+DI]}$)。<br>用于动态地址计算或 <mark>不影响标志位</mark> 的算术运算。</dd></dl>`},
    {front:"加载 <mark>远指针</mark> 指令 (LDS, LES, LSS, etc.) 🔗",back:`<dl><dt>作用</dt><dd><mark>一次性</mark> 从内存加载一个 <mark>远指针</mark> (段选择子 $\\text{+ 偏移地址}$)。</dd><dt>指令格式</dt><dd>$\\text{LDS reg, mem}$ (Load $\\text{DS}$ and $\\text{reg}$)。</dd><dt>LDS 执行流程</dt><dd>1. 从 $\\text{mem}$ 处读取 <mark>偏移地址</mark> ($\text{Offset}$)，存入 $\\text{reg}$。<br>2. 紧接着读取 <mark>段选择子</mark> ($\text{Segment Selector}$)，存入 <mark>DS</mark> 寄存器。</dd><dt>应用场景</dt><dd>快速 <mark>切换堆栈</mark> ($\text{LSS SP, SADDR}$)，在多任务/内核环境尤为重要。</dd></dl>`},
    {front:"<mark>串操作指令</mark> (String Instructions) 的 <mark>核心要素</mark> 🎯",back:`<dl><dt>源地址 (Source)</dt><dd>由 <mark>DS:SI/ESI</mark> 指向。</dd><dt>目的地址 (Destination)</dt><dd>由 <mark>ES:DI/EDI</mark> 指向 (DI/EDI 默认关联 $\\text{ES}$ 段，且 <mark>不可被段前缀覆盖</mark>)。</dd><dt>方向标志 (DF)</dt><dd><mark>DF=0</mark> ($\text{CLD}$): 指针 <mark>递增</mark> (从前往后处理，最常用)。<br><mark>DF=1</mark> ($\text{STD}$): 指针 <mark>递减</mark> (从后往前处理，防内存 <mark>重叠覆盖</mark>)。</dd><dt>重复前缀 (REP)</dt><dd>指令前加 $\\text{REP}$，用 $\\text{CX/ECX}$ 作为计数器，<mark>自动重复</mark> 执行，每执行一次 $\\text{CX}$ 自动减 1。</dd></dl>`},
    {front:"串传送指令：<mark>LODS</mark> 与 <mark>STOS</mark> 读写操作 📖",back:`<dl><dt>LODS (Load String)</dt><dd>功能：从 <mark>DS:SI</mark> $\\to$ <mark>累加器</mark> ($\text{AL/AX/EAX}$)。<br>用途：<mark>逐个元素处理</mark> 字符串/数组。</dd><dt>STOS (Store String)</dt><dd>功能：从 <mark>累加器</mark> ($\text{AL/AX/EAX}$) $\\to$ <mark>ES:DI</mark>。<br>用途：常配合 $\\text{REP}$ 前缀，将内存区域 <mark>初始化</mark> 为同一值 (如 $\\text{memset}$)。</dd><dt>REP LODS / REP STOS</dt><dd>REP LODS <mark>无意义</mark> (累加器值被不断覆盖)。<br>REP STOS <mark>高效</mark> (源累加器值不变，反复写入内存)。</dd></dl>`},
    {front:"串传送指令：<mark>MOVS</mark> 内存复制 📝",back:`<dl><dt>功能</dt><dd><mark>内存 $\\to$ 内存</mark> 的数据复制 (从 $\\text{DS:SI}$ $\\to$ $\\text{ES:DI}$)。</dd><dt>核心特点</dt><dd>MOVS 是 x86 架构中 <mark>唯一</mark> 允许 <mark>内存 $\\to$ 内存</mark> 直接传送的指令。</dd><dt>用途</dt><dd>任何 <mark>内存块复制</mark> (如 C 语言的 $\\text{memcpy()}, \\text{strcpy()}$)。<br>底层最有效率的实现是 <mark>REP MOVSB/W/D</mark>。</dd><dt>操作数后缀</dt><dd><mark>B</mark> (Byte, $\\pm 1$), <mark>W</mark> (Word, $\\pm 2$), <mark>D</mark> (Doubleword, $\\pm 4$)。</dd></dl>`},
    {front:"串 I/O 指令：<mark>INS</mark> 与 <mark>OUTS</mark> 🔄",back:`<dl><dt>INS (Input String)</dt><dd>功能：从 <mark>I/O 端口 (DX)</mark> $\\to$ <mark>内存 (ES:DI)</mark>。<br>用途：从外部设备 <mark>高速读取数据块</mark> 到内存缓冲区 (如读取磁盘扇区)。</dd><dt>OUTS (Output String)</dt><dd>功能：从 <mark>内存 (DS:SI)</mark> $\\to$ <mark>I/O 端口 (DX)</mark>。<br>用途：将内存中的数据块 <mark>发送到外部设备</mark> (如写显存、发送网络数据)。</dd><dt>I/O 端口地址</dt><dd>必须在 $\\text{DX}$ 寄存器中，不能是立即数。</dd><dt>常用形式</dt><dd><mark>无操作数形式</mark> ($\text{INSB/INSW}, \\text{OUTSB/OUTSW}$) 更简洁常用。</dd></dl>`}
  ]
};
