// data/java-w2-review.js
export default {
  name: "Java: 2 Basic Java",
  data: [
    {front:"原始类型 vs 包装类 📦", back:"<dl><dt>两大类型</dt><dd>Java数据类型分为8种 <mark>原始类型</mark> (如 <code>int</code>, <code>double</code>) 和它们对应的 <mark>包装类</mark> (<code>Integer</code>, <code>Double</code>)。</dd><dt>区别</dt><dd><b>原始类型</b>：存储值，性能高，非对象，存于栈。<br><b>包装类</b>：存储对象，功能丰富，存于堆，用于泛型等面向对象场景。</dd></dl>"},
    {front:"自动装箱/拆箱 🍬", back:"<dl><dt>定义</dt><dd>编译器提供的“语法糖”，简化原始类型与包装类间的转换。</dd><dt>自动装箱 (Auto-boxing)</dt><dd>将原始类型自动转换为包装类对象。<br><code>Integer a = 100;</code> 背后是 <code>Integer.valueOf(100);</code></dd><dt>自动拆箱 (Auto-unboxing)</dt><dd>将包装类对象自动转换回原始类型。<br><code>int b = a;</code> 背后是 <code>a.intValue();</code></dd></dl>"},
    {front:"创建包装类对象的正确姿势 ✅", back:"<dl><dt>现代实践</dt><dd>使用静态工厂方法 <code>valueOf()</code> 或自动装箱，而非过时的 <code>new</code> 构造器。</dd><dt>原因 (性能)</dt><dd><code>new Integer(5)</code> 每次都创建新对象，浪费内存。<br><code>Integer.valueOf(5)</code> 会利用内部缓存，对常用值 (默认-128到127) 返回已存在的对象，性能更高。</dd><dt>结论</dt><dd><code>new Integer(123)</code> 已从JDK 9起被废弃，现在直接导致编译失败。</dd></dl>"},
    {front:"包装类的缓存机制 🧊", back:"<dl><dt>缓存范围</dt><dd>为提高性能，Java缓存了常用值的包装类对象。</dd><dd><b>Integer, Short, Byte, Long</b>: <code>-128</code> 到 <code>127</code></dd><dd><b>Character</b>: <code>0</code> 到 <code>127</code></dd><dd><b>Boolean</b>: <code>true</code> 和 <code>false</code></dd><dt>典型陷阱</dt><dd><code>Integer i1 = 12; Integer i2 = 12;</code><br>因为12在缓存内, 所以 <code>i1 == i2</code> 结果为 <mark>true</mark>。<br><code>Integer i3 = 1200; Integer i4 = 1200;</code><br>因为1200超出缓存, 创建了新对象, 所以 <code>i3 == i4</code> 结果为 <mark>false</mark>。</dd></dl>"},
    {front:"为什么 Java 没有 <code>unsigned</code>？ 🤔", back:"<dl><dt>设计哲学</dt><dd>Java 的设计者 James Gosling 认为 C/C++ 中的无符号类型是许多难以发现的bug的根源（例如有符号数和无符号数混合运算）。</dd><dt>简单与安全</dt><dd>为了贯彻 <mark>简单、安全</mark> 的设计哲学，Java决定不支持 <code>unsigned</code>，从而减少语言复杂性和潜在错误。</dd><dt>解决方案</dt><dd>当需要处理无符号数据时（如32位无符号整数），可以使用更大范围的有符号类型来解决，例如用 <code>long</code>。</dd></dl>"},
    {front:"<code>String</code> 的不可变性 (Immutability) 🔒", back:"<dl><dt>核心概念</dt><dd>一旦 <code>String</code> 对象被创建，其内部的字符序列就 <mark>永远不能被改变</mark>。</dd><dt>方法行为</dt><dd>所有类似修改的方法，如 <code>.trim()</code>, <code>.substring()</code>, <code>.toUpperCase()</code>，都不会改变原始字符串。它们会 <mark>返回一个全新的 String 对象</mark>。</dd><dt>代码示例</dt><dd><code>String s = \" abc \";<br>s.trim(); // 这行代码无效，s仍然是\" abc \"<br>s = s.trim(); // 正确做法：将新对象的引用赋回给s</code></dd></dl>"},
    {front:"为什么 <code>String</code> 不可变如此重要？ ✨", back:"<dl><dt>字符串常量池</dt><dd>不可变性使得 <mark>字符串常量池 (String Pool)</mark> 成为可能，相同内容的字符串可以被共享，节省内存。</dd><dt>线程安全</dt><dd>天生线程安全，多个线程可以无锁访问同一个字符串对象。</dd><dt>安全性</dt><dd>在网络连接、文件路径、类加载等场景，防止恶意代码修改关键参数。</dd><dt>哈希性能</dt><dd>因为内容不变，<code>hashCode()</code> 只需计算一次并缓存，在 <code>HashMap</code> 等集合中作为Key时性能极高。</dd></dl>"},
    {front:"创建字符串：字面量 vs <code>new</code> 🏊", back:"<dl><dt>字符串字面量</dt><dd><code>String s1 = \"Hello\";</code><br>编译器会先在 <mark>字符串常量池</mark> 查找。如果存在，直接返回引用；如果不存在，则创建并放入池中。</dd><dt><code>new</code> 操作符</dt><dd><code>String s2 = new String(\"Hello\");</code><br>这个操作会创建 <mark>两个对象</mark>：一个在常量池中（如果不存在的话），另一个是 <mark>必定在堆内存中创建的新对象</mark>。</dd><dt>比较</dt><dd><code>\"Hello\" == \"Hello\"</code> -> true<br><code>new String(\"Hello\") == \"Hello\"</code> -> false</dd></dl>"},
    {front:"对象比较：<code>==</code> vs <code>.equals()</code> 📜", back:"<dl><dt>黄金法则</dt><dd>比较字符串内容是否相等时，永远、永远、永远使用 <code>.equals()</code> 方法！</dd><dt><code>==</code></dt><dd>当用于对象时，比较的是两个引用是否指向 <mark>同一个内存地址</mark>（身份比较）。</dd><dt><code>.equals()</code></dt><dd>对于 <code>String</code> 类，该方法被重写(override)用来比较两个字符串的 <mark>内容是否完全相同</mark>（值比较）。</dd></dl>"},
    {front:"字符串拼接：<code>+</code> 与 <code>StringBuilder</code> 🚀", back:"<dl><dt><code>+</code> 拼接规则</dt><dd>运算从左到右，一旦表达式中出现字符串，后续所有 <code>+</code> 都将变为字符串拼接操作。<br><code>1 + 2 + \"a\"</code> -> <code>\"3a\"</code><br><code>\"a\" + 1 + 2</code> -> <code>\"a12\"</code></dd><dt>性能陷阱</dt><dd>在循环中使用 <code>+</code> 拼接字符串效率极低，因为每次循环都会创建一个新的 <code>StringBuilder</code> 和 <code>String</code> 对象。</dd><dt>最佳实践</dt><dd>当需要多次拼接字符串时（尤其在循环中），应显式使用 <mark>StringBuilder</mark> (非线程安全，更快) 或 <mark>StringBuffer</mark> (线程安全，稍慢)。</dd></dl>"},
    {front:"Java 参数传递：纯粹的按值传递 ✉️", back:"<dl><dt>核心机制</dt><dd>Java <mark>只有按值传递 (Pass-by-Value)</mark>。</dd><dt>原始类型</dt><dd>方法接收的是实际值的 <mark>副本</mark>。方法内对参数的修改不影响外部变量。<br><code>void f(int n) { n=9; }</code></dd><dt>对象类型</dt><dd>方法接收的是对象 <mark>引用的副本</mark> (即内存地址的副本)。因为副本和原始引用指向同一个堆中对象，所以在方法内可以通过该引用副本 <mark>修改对象内部的状态</mark>，但无法让外部的原始引用指向一个新对象。<br><code>void f(Number n) { n.i=9; }</code></dd></dl>"},
    {front:"类的初始化顺序（超重点） 🏗️", back:"<dl><dt>完整顺序</dt><dd>一个对象创建的完整生命周期遵循严格顺序：</dd><dd>1. <b>父类静态</b>：静态变量和静态初始化块。<br>2. <b>子类静态</b>：静态变量和静态初始化块。<br>3. <b>父类实例</b>：实例变量和实例初始化块。<br>4. <b>父类构造器</b>。<br>5. <b>子类实例</b>：实例变量和实例初始化块。<br>6. <b>子类构造器</b>。</dd><dt>关键点</dt><dd>静态部分只在类首次加载时执行一次，实例部分在每次创建对象时都执行。</dd></dl>"},
    {front:"访问控制修饰符 🔑", back:"<dl><dt>四种级别 (权限从高到低)</dt><dd><b><code>public</code></b>: 公开的，任何地方都可以访问。</dd><dd><b><code>protected</code></b>: 受保护的，同包内、不同包的子类可访问。</dd><dd><b><code>default</code> (无关键字)</b>: 包私有的，仅在同一个包内可访问。</dd><dd><b><code>private</code></b>: 私有的，仅在同一个类内部可访问。</dd></dl>"},
    {front:"<code>final</code> 关键字的三种用法 🚫", back:"<dl><dt>修饰变量 (常量)</dt><dd><b>基本类型</b>：值不能被改变。<br><b>引用类型</b>：引用地址不能被改变（不能指向其他对象），但对象自身的内容可以修改。</dd><dt>修饰方法</dt><dd>该方法 <mark>不能被子类重写 (override)</mark>。</dd><dt>修饰类</dt><dd>该类 <mark>不能被继承</mark>。例如 <code>String</code>, <code>Integer</code> 都是 final 类。</dd></dl>"},
    {front:"<code>static</code> 静态成员 🏛️", back:"<dl><dt>核心概念</dt><dd>静态成员属于 <mark>类本身</mark>，而不是类的某个具体实例(对象)。</dd><dt>共享性</dt><dd>被该类的所有对象 <mark>共享</mark>。任何一个对象修改了静态变量，其他对象看到的值都会改变。</dd><dt>生命周期</dt><dd>在类被加载到内存时初始化，比任何对象的创建都要早。可以通过 <mark>类名.静态成员</mark> 直接访问，无需创建对象。</dd></dl>"},
    {front:"小结 ✅", back:"<dl><dt>基础</dt><dd>理解原始类型与包装类的区别、自动装箱拆箱是Java基础。</dd><dt>核心</dt><dd><code>String</code> 的不可变性及其带来的好处是面试和编程的核心知识点。</dd><dt>实践</dt><dd>牢记用 <code>.equals()</code> 比较内容，用 <code>StringBuilder</code> 高效拼接字符串。</dd><dt>概念</dt><dd>精通按值传递、类的初始化顺序、访问控制和关键字用法是成为专业程序员的基石。</dd></dl>"}
  ]
};